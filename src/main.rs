use actix_web::{get, post, put, delete, web, App, HttpRequest, HttpResponse, HttpServer, Responder, ResponseError};
use actix_web::http::header::ContentType;
use actix_web::http::StatusCode;
use actix_web::body::BoxBody;

use serde::{Serialize, Deserialize};

use std::fmt::Display;
use std::sync::Mutex;
use std::collections::HashMap;

use rand::Rng;

// prime base of modulus 
const G: u64 = 4;
// another prie base of modulus 
const H: u64 = 9;
// prime number of finite field
const P: u64 = 23;
// prime order of G, H mod P
const Q: u64 = 11;

/// params to initialize a user and its y1, y2
#[derive(Serialize, Deserialize)]
struct Ticket {
    id: u64,
    username: String,
    // registered y1 = g ^ x (x is a secret number only user holds)
    y1: u64,
    // registered y2 = h ^ x (x is a secret number only user holds)
    y2: u64,
}

/// params to update a user with new y1, new y2
#[derive(Serialize, Deserialize)]
struct UpdateTicket {
    id: u64,
    username: String,
    // registered y1 = g ^ x (x is a secret number only user holds)
    y1: u64,
    // registered y2 = h ^ x (x is a secret number only user holds)
    y2: u64,
    new_y1: u64,
    new_y2: u64,
}

/// params to commit a user's r1, r2
#[derive(Serialize, Deserialize)]
struct CommitTicket {
    id: u64,
    username: String,
    // registered y1 = g ^ x (x is a secret number only user holds)
    y1: u64,
    // registered y2 = h ^ x (x is a secret number only user holds)
    y2: u64,
    r1: u64,
    r2: u64,
    c: u64,
}

/// params to login a user with its computed s
#[derive(Serialize, Deserialize, Clone)]
struct LogInTicket {
    id: u64,
    // send over s = k - c*x
    s: u64, 
}

/// helper function to generate trandom x, k for the user, if the user is lazy
/// and y1, y2 corresponding to x, r1, r2, corresponding to k 
#[derive(Serialize, Deserialize, Clone, Debug)]
struct GenerateRandomTicket {
    // random number by rng
    x: u64,
    // G^x mod P
    y1: u64,
    // H^x mod P
    y2: u64,
    // random number by rng
    k: u64,
    // G^k mod P
    r1: u64,
    // H^k mod P
    r2: u64, 
}

/// give user a view of the common pamameters of this code
#[derive(Serialize, Deserialize, Clone, Debug)]
struct ParamTicket {
    g: u64,
    h: u64,
    p: u64,
    q: u64,
}

/// compute and send back s on the input of x, k, c from user 
#[derive(Serialize, Deserialize, Clone, Debug)]
struct ComputeTicket {
    x: u64,
    k: u64,
    c: u64,
    s: u64,
}

/// user data structure stored in the hash table
#[derive(Serialize, Deserialize, Clone, Debug)]
struct User {
   id: u64,
   username: String,
   /// registered y1 = g ^ x mod P(x is a secret number only user holds)
   y1: u64, 
   /// registered y2 = h ^ x mod P
   y2: u64, 
   /// committed r1 = g ^ k mod P(k is a randon number generated by Ticket)
   r1: u64, 
   /// committed r2 = h ^ k mod P
   r2: u64, 
   /// c is the challenge generated randomly by verifier (this server)
   c: u64, 
   /// s = (k - c * x) mod Q
   s: u64, 
   state: UserState,
}

/// 3 states of a user 
#[derive(Debug, Clone, Eq, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum UserState {
    Registered,
    Committed,
    Authenticated,
}

// Implement Responder Trait for Ticket
impl Responder for Ticket {
   type Body = BoxBody;

   fn respond_to(self, _req: &HttpRequest) -> HttpResponse<Self::Body> {
       let res_body = serde_json::to_string(&self).unwrap();

       // Create HttpResponse and set Content Type
       HttpResponse::Ok()
           .content_type(ContentType::json())
           .body(res_body)
   }
}

// Implement Responder Trait for User
impl Responder for User {
    type Body = BoxBody;
 
    fn respond_to(self, _req: &HttpRequest) -> HttpResponse<Self::Body> {
        let res_body = serde_json::to_string(&self).unwrap();
 
        // Create HttpResponse and set Content Type
        HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(res_body)
    }
 }



#[derive(Debug, Serialize)]
/// error message structure
struct ErrNoId {
   id: u64,
   err: String,
}

// Implement ResponseError for ErrNoId
impl ResponseError for ErrNoId {
   fn status_code(&self) -> StatusCode {
       StatusCode::NOT_FOUND
   }

   fn error_response(&self) -> HttpResponse<BoxBody> {
       let body = serde_json::to_string(&self).unwrap();
       let res = HttpResponse::new(self.status_code());
       res.set_body(BoxBody::new(body))
   }
}

// Implement Display for ErrNoId
impl Display for ErrNoId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
 }

/// user data stored in a hashmap with Mutex guard
/// multi threading ready
struct AppState {
    // users: Mutex<Vec<User>>,
    users: Mutex<HashMap<u64, User>>,
}

 /// ticket to create a user with id, username, y1, y2
#[post("/tickets")]
async fn post_ticket(req: web::Json<Ticket>, data: web::Data<AppState>) -> impl Responder {
   let new_user = User {
       id: req.id,
       username: String::from(&req.username),
       y1: req.y1,
       y2: req.y2,
       r1: 0,
       r2: 0,
       c: 0,
       s: 0,
       state: UserState::Registered,
   };

   let mut tickets = data.users.lock().unwrap();

   let response = serde_json::to_string(&new_user).unwrap();

   // tickets.push(new_user);
   tickets.entry(new_user.id).or_insert(new_user);
   HttpResponse::Created()
       .content_type(ContentType::json())
       .body(response)
}

/// ticket to commit a user with r1, r2
#[post("/tickets/commit/{id}")]
async fn commit_ticket(id: web::Path<u64>, req: web::Json<CommitTicket>, data: web::Data<AppState>) -> Result<HttpResponse, ErrNoId> {
    let user_id = *id;
    let mut users = data.users.lock().unwrap();
    let user = users.get(&user_id);
    match user {
        Some(u) => {
            // check that credentials match
            if u.username != req.username || u.y1 != req.y1 || u.y2 != req.y2 {
                let response = ErrNoId {
                    id: user_id,
                    err: String::from("wrong credentials")
                };
                return Err(response);
            // user state must be Registered or above
            } else if u.state != UserState::Registered {
                let response = ErrNoId {
                    id: user_id,
                    err: String::from("wrong state, not allowed to commit")
                };
                return Err(response);

            } else {
                let mut rng = rand::thread_rng();
                let challenge = rng.gen_range(10..50);
                let updated_user = User {
                    id: u.id,
                    username: String::from(u.username.clone()),
                    y1: u.y1,
                    y2: u.y2,
                    r1: req.r1,
                    r2: req.r2,
                    c: challenge,
                    s: 0,
                    state: UserState::Committed,
                };

                println!("committed user is {:?}", updated_user.clone());

                let updated_commit = CommitTicket {
                    id: req.id,
                    username: String::from(u.username.clone()),
                    y1: req.y1,
                    y2: req.y2,
                    r1: req.r1,
                    r2: req.r2,
                    c: challenge,
                };
                users.insert(user_id, updated_user);

                let response = serde_json::to_string(&updated_commit).unwrap();
            
                Ok(HttpResponse::Ok()
                .content_type(ContentType::json())
                .body(response)
                )
                
            }
        },
        None => {
            let response = ErrNoId {
                id: user_id,
                err: String::from("ticket not found")
            };
            Err(response)
        }
    }
}


/// helper function to compute s = (k - c*x) mod Q
/// help to test with web client
/// the function isn't needed in real environment
#[post("/tickets/compute")]
async fn compute_ticket(req: web::Json<ComputeTicket>) -> impl Responder {

    let a = (req.k as i64) - (req.c  as i64) * (req.x as i64);

    // s = (k - c*x) mod q
    // modulo ((a % q) + q) % q
    let s = ((a % (Q as i64)) + (Q as i64)) % (Q as i64);

    let mut r = req.clone();
    r.s = s as u64;

    let response = serde_json::to_string(&r).unwrap();

   HttpResponse::Ok()
       .content_type(ContentType::json())
       .body(response)

}

/// ticket to log in a user with user id and s value
#[post("/tickets/login/{id}")]
async fn login_ticket(id: web::Path<u64>, req: web::Json<LogInTicket>, data: web::Data<AppState>) -> Result<HttpResponse, ErrNoId> {
    let user_id = *id;
    let mut users = data.users.lock().unwrap();
    let user = users.get_mut(&user_id);
    match user {
        Some(u) => {
            let s = req.s;
            // r1 = (g^s * y1^c) mod P; 
            // r2 = (h^s * y2^c) mod P;
            // these will be positive numbers so we can use remainder
            let r1 = ((G.pow(s as u32)%P) * ((u.y1).pow(u.c as u32)%P)) % P;
            let r2 = ((H.pow(s as u32)%P) * ((u.y2).pow(u.c as u32)%P)) % P;
            println!("r1 is = {} user r1 = {}", r1, u.r1);
            println!("r2 is = {} user r2 = {}", r2, u.r2);
            if r1 == u.r1 && r2 == u.r2 {
                println!("user in map is: {:?}", u.clone());
                let mut new_user = u.clone();
                new_user.s = req.s;
                new_user.r1 = r1;
                new_user.r2 = r2;
                new_user.state = UserState::Authenticated;
                
                let response = serde_json::to_string(&new_user).unwrap();

                users.insert(user_id, new_user);

                Ok(HttpResponse::Ok()
                .content_type(ContentType::json())
                .body(response)
                )
            } else {
                let response = ErrNoId {
                    id: user_id,
                    err: String::from("wrong answer, authentication fails")
                };
                Err(response)
            }
            
        }
        None => {
            let response = ErrNoId {
                id: user_id,
                err: String::from("ticket not found")
            };
            Err(response)
        }
    }
}


/// helper function to generate random parameters for "lazy" users
/// users should use their own random number generators instead of this function
/// for testers to have some easy access to some numbers only
#[get("/tickets/random")]
async fn get_random() -> impl Responder {
    let mut rng = rand::thread_rng();
    let x: u64 = rng.gen_range(2..10);
    let y1 = G.pow(x as u32) % P;
    let y2 = H.pow(x as u32) % P;
    let k: u64 = rng.gen_range(2..10);
    let r1 = G.pow(k as u32) % P;
    let r2 = H.pow(k as u32) % P;

    let res = GenerateRandomTicket {
        x,
        y1,
        y2,
        k,
        r1,
        r2,
    };

    println!("generate random is: {:?}", res.clone());

    let response = serde_json::to_string(&res).unwrap();

    HttpResponse::Ok()
       .content_type(ContentType::json())
       .body(response)

}

/// for users to look up the common parameters used by this program
#[get("/tickets/params")]
async fn get_params() -> impl Responder {
    let res = ParamTicket {
        g: G,
        h: H,
        p: P,
        q: Q,
    };

    let response = serde_json::to_string(&res).unwrap();

    HttpResponse::Ok()
       .content_type(ContentType::json())
       .body(response)

}

/// Get a ticket detail with the corresponding id
#[get("/tickets/{id}")]
async fn get_ticket(id: web::Path<u64>, data: web::Data<AppState>) -> Result<Ticket, ErrNoId> {
   let user_id: u64 = *id;
   let users = data.users.lock().unwrap();
   let user = users.get(&user_id);
   match user {
    Some(u) => {
        Ok(Ticket {
            id: u.id,
            username: u.username.clone(),
            y1: u.y1,
            y2: u.y2,
        })
    },
    None => {
        let response = ErrNoId {
            id: user_id,
            err: String::from("ticket not found")
        };
        Err(response)
    },
   }
}

/// Update the ticket's y1, y2 with the corresponding id
#[put("/tickets/{id}")]
async fn update_ticket(id: web::Path<u64>, req: web::Json<UpdateTicket>, data: web::Data<AppState>) -> Result<HttpResponse, ErrNoId> {
   let ticket_id: u64 = *id;

   let mut users = data.users.lock().unwrap();

   let user = users.get_mut(&ticket_id);

   match user {
       Some(u) => {
        if u.username != req.username || u.y1 != req.y1 || u.y2 != req.y2 {
            let response = ErrNoId {
                id: ticket_id,
                err: String::from("wrong credentials")
            };
            return Err(response);
        } else {

            let new_user = User {
                id: u.id,
                username: String::from(u.username.clone()),
                y1: req.new_y1,
                y2: req.new_y2,
                r1: 0,
                r2: 0,
                c: 0,
                s: 0,
                state: UserState::Registered,
            };

            // *users.entry(ticket_id).or_insert(new_user);
            users.insert(ticket_id, new_user);

            let response = serde_json::to_string(&req).unwrap();
            
            Ok(HttpResponse::Ok()
               .content_type(ContentType::json())
               .body(response)
            )
        }
           
       },
       None => {
           let response = ErrNoId {
               id: ticket_id,
               err: String::from("ticket not found")
           };
           Err(response)
       }
   }
}

/// Delete the ticket with the corresponding id
#[delete("/tickets/{id}")]
async fn delete_ticket(id: web::Path<u64>, req: web::Json<Ticket>, data: web::Data<AppState>) -> Result<Ticket, ErrNoId> {
   let ticket_id: u64 = *id;

   let mut users = data.users.lock().unwrap();

   let user = users.get(&ticket_id);

   match user {
       Some(u) => {
           if u.id !=req.id || u.username != req.username || u.y1 != req.y1 && u.y2 != req.y2 {
            let response = ErrNoId {
                id: ticket_id,
                err: String::from("no match on credentials")
            };
            return Err(response);
           } else {
            let deleted_user = users.remove(&ticket_id).unwrap();
            let deleted_ticket = Ticket{
                id: ticket_id,
                username: deleted_user.username,
                y1: deleted_user.y1,
                y2: deleted_user.y2,
            };
            return Ok(deleted_ticket);
           }
       },
       None => {
           let response = ErrNoId {
               id: ticket_id,
               err: String::from("ticket not found")
           };
           Err(response)
       }
   }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    println!("listening on 127.0.0.1:8000");
    let mock_users = HashMap::new();
   let app_state = web::Data::new(AppState {
                        users: Mutex::new(mock_users)
                    });

   HttpServer::new(move || {
       App::new()
           .app_data(app_state.clone())
           .service(get_params)
           .service(get_random)
           .service(post_ticket)
           .service(commit_ticket)
           .service(compute_ticket)
           .service(login_ticket)
           .service(get_ticket)
           .service(update_ticket)
           .service(delete_ticket)
   })
   .bind(("127.0.0.1", 8000))?
   .run()
   .await
}